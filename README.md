 # 数据结构
 ## 复杂度分析
 ### 空间复杂度
 ### 时间复杂度

 ## 数据结构
 ### 数组(Array)
 >优点：   
  * 可利用cpu的预读缓存功能，提高读取效率  
  * 随机访问  
    ```
    a[i]=firstAddress + offset * i;
    ```  
    tips:`为何数组下标是从0开始?`  
    > C语言风格继承  
    > 如果是从1开始，寻址时多一个减法运算  
    ```
     a[i]=firstAddress + offset * (i-1);
    ```
 >缺点:
 * 长度固定不可变
 * 如果内存中碎片多，在创建数组时，虽然可用内存能够支持创建一个数组，但是由于可用内存不联系可能会发生异常。
 * 插入和删除效率低，插入和删除的元素后面的所有元素都要相应的移动一位。  
    * 优化：执行删除操作时将数据标记为删除状态而不实际删除，当数组没有空间添加数据时，一次性真正删除。  
    tips：`类似GC垃圾对象回收对象时的思想`  
 >性能：
 * 随机访问O(1)
 * 删除、插入O(n)
 >二维数组
 * 数据结构上是用1维数组模拟产生
 * 寻址：
 ```
 //a数组长度m*n
 a[i][j]=firstAddress + offset * (i*n+j);
 ```
 >使用场景
 * 多随机访问，少删除、插入
 ### 链表(linked)
 >结构
  * 节点(node)  
    * 包含若干指针和数据变量  
  * 头节点(head)  
    * 第一个节点
  * 尾节点(tail)
    * 最后一个节点
 >优点
 * 长度可变
 * 插入删除快
 >缺点
 * 随机访问要从头遍历
 * 每个node需要消耗额外内存存储next node的指针
 * 删除操作频繁的释放内存，容易产生内存碎片，导致GC回收。 
 >性能
 * 访问O(n)
 * 插入、删除O(1)
 >种类
 * 单向链表  
    ```
    tail.next=null;
     ```
 * 双向链表
     ```
    head.pre = null;
    head.next=second;
    second.pre=head;
    ```
 * 循环链表
    ```
    tail.next=head;
    ```
 * 双向循环列表
    ```
    head.pre=tail;
    tail.next=head;
     ```
  >使用场景
  * 多插入、删除，少随机访问
  > 练习
  * 链表反转
    ```
          public void reverse(){
                  Node cur = header;
                  Node befor = null;
                  Node next = null;
                  while (cur!=null){
                          next = cur.next;
                          swap(befor,cur);
                          befor = cur;
                          cur = next;
                  }
                  header = befor;
              }
    ```
  * 环检测
    ```
            快慢指针，slow每次行动一个Node，quick指针每次移动2个Node  
            如果quick指针走到尾之前，2个指针能遇到（相等），则说明有环
    ```
  * 找到链表的中间节点
    ```
            快慢指针，slow一次移动一个Node，quick一次移动2个Node  
            当quick移动到尾部时，slow节点就是中间节点（需要考虑奇偶性）
    ```
 ### 栈(stack)
 >特点：  
  * LIFO
  * 操作受限；只有出栈(pop)、入栈(push)操作
 >实现方式：
  * 链表
  * 数组
 >应用：
 * 函数调用
 * 表达式求值
 * 括号匹配
 * 浏览器前进、后退
 ### 队列(queue)
 >特点：
 * FIFO
 * 操作受限；只有出队(dequeue)、入队(enqueue)操作
 >实现方式：
 * 链表
 * 数组
 >种类：
 * 循环队列
 * 阻塞队列
 * 并发队列
 * 优先队列
 >应用：
 * Java concurrent 并发包利用，ArrayBlockingQueue 来实现公平锁等
 * 高性能队列 Disruptor
 * Linux 环形缓存
 * 线程池、连接池
 ### 跳表(skip list)
 ### 散列表(hash table)
 >优点：
 >缺点：
 >LRU
 ### 树(tree)
 #### 二叉树(Binary Tree)  
 每个节点最多有2个子节点
 #### 满二叉树  
 叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点
 #### 完全二叉树：
 叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大
 #### 数据结构
 * 链式结构  
 使用链表存储，每个节点保存子左节点、子右节点的指针
 * 数组结构
 将树节点映射到数组中
    ```
    根节点 = a[1];
    节点a[i]的左节点为a[i*2],右节点为a[i*2+1],父节点为a[i/2];
    倒数第一个非叶节点=a[n/2],n为树中最后一个节点的下标。
    ```
    数组存储用于完全二叉树，完全二叉树能保证节点全是连续的，最大限度的不浪费内存  
    链式存储要多用2个指针，所以完全二叉树和数组完美匹配。
 #### 树遍历(O(n))
 * 前序遍历  
   先打印根节点->打印左节点->打印右节点
 * 中序遍历  
   先打印左节点->打印根节点->打印右节点
 * 后续遍历  
   先打印左节点->打印右节点->打印根节点
 * 按层遍历
 ### 堆(heap)
 >优点：
 >缺点：
 ### 图(graph)
 >优点：
 >缺点：
 
 ## 排序
 ### 冒泡(bubble sort)  
 双层for循环，第一层控制冒泡次数，第二层比较相邻2个元素    
 if(befor>after) swap(befor,after);
 ### 选择(selection sort)  
 将数组分为已排区和待排区，每次从待排区找出最小的元素放入已排区  
 ### 插入(insertion sort)  
 将数组分为已排区和待排区，每次用待排区的第一个元素和已排区的元素    
 从右到左比较大小，找到第一个小于待排元素的元素，将待排元素插入其后面  
 ### 归并(merge sort)
 分治的思想，递归的手段，先局部有序，后整体有序  
 * 步骤一分解，每次递归将数组分为2部分，直到一个元素终止。  
 * 步骤二合并，将2部分按照大小顺序合并成一个有序数组
 ### 快速(quick sort)
 分治的思想，递归的手段，先范围间有序，后局部有序。  
 取一个元素，将比这个元素小的放左边分区，比这个元素大的放右边分区  
 递归对子分区继续分区，直到最小分区有序，整个数组自然就有序了。
 ### 桶(bucket sort)  
 定义每个桶存可以存放对应区间内的数，桶按照区间有序。  
 将待排的元素，落到响应的桶中，再将每个桶内进行快速排序。  
 按照桶的顺序全部取出，就拍好了顺序。  
 * 使用场景
    * 适用外部排序，即数据量巨大，存储在磁盘上，不能一次性加载到内存
    * 很容易划分成m个桶
    * 数据要分布均匀，极端情况都落入一个桶中，退化为快排O(nlogn)
 ### 计数(counting sort)
 桶排序的变种
 * 使用场景
    * 数据范围不大
    * 每个桶保存相同的数
    * 数据不是非负要转化为非负
 ### 基数(radix sort)
 将数据范围非常大，不适合桶排序的数据，转化成对一条数据中的每一位数  
 进行桶排序。例如对手机号排序。  
 * 注意
    * 桶内排序一定要是稳定的排序方式。
    * 位数不一样长的情况，在数的前面补0，
 
 ### 堆(heap sort)
 ### 常见排序复杂度分析
 | Name | 原地 | 稳定 | 最好 | 最坏 | 平均 |  
 | - | :-: | :-: | :-: | :-: | -: | 
 | 冒泡 | 是 | 是 | O(n) | O(n2) | O(n2) |
 | 选择 | 是 | 是 | O(n) | O(n2) | O(n2) |
 | 插入 | 是 | 否 | O(n2) | O(n2) | O(n2) |
 | 归并 | 否 | 否 | O(nlogn) |O(nlogn) | O(nlogn) |
 | 快速 | 是 | 否 | O(nlogn) | O(n2) | O(nlogn) |
 | 堆排序| 是 | 否 | O(n) | O(n) | O(nlogn) |
 | 桶排序| 否 | 否 | O(n) | O(n) | O(n) |
 | 计数排序| 否 | 否 | O(n) | O(nlogn) | O(n) |
 | 基数排序| 否 | 否 | O(n) | O(n) | O(n) |
 



 ## 策略
 ### 贪婪(greedy)
 ### 分治(devide and conquer)  
 将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题  
 递归地解决这些子问题，然后再合并其结果，就得到原问题的解。
 * 分解：将原问题分解成一系列子问题；
 * 解决：递归地求解各个子问题，若子问题足够小，则直接求解；
 * 将子问题的结果合并成原问题
 <br>
 分治算法能解决的问题，一般需要满足下面这几个条件：
 * 原问题与分解成的小问题具有相同的模式;
 * 原问题分解成的子问题可以独立求解，子问题之间没有相关性;
 * 具有分解终止条件，也就是说，当问题足够小时，可以直接求解;
 ### 回溯(BackTracking)
 ### 动态规划(Dynamic Programming)
 
 ## 查找
 ### 二分查找
 ### 查并集
